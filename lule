#!/usr/bin/env bash

VERSION="0.1"
#load .profle ariables, lule uses $LULE_W, $LULE_C, $LULE_S
if [ -f $HOME/.profile ]; then
    source $HOME/.profile
fi

#create ccache directory if does not exist
if [ ! -d $HOME/.cache/wal ]; then
    mkdir -p $HOME/.cache/wal;
fi

#create config directory and file if does not exist
if [ ! -d $HOME/.config/lule ]; then
    mkdir -p $HOME/.config/lule;
    if [ ! -f $HOME/.config/lule/configs.json ]; then
        touch $HOME/.config/lule/configs.json
    fi
fi


declare -ra col=(
    $'\e[1;0m'      # normal  ## col[0]
    $'\e[1;31;40m'  # red     ## col[1]
    $'\e[1;32;40m'  # green   ## col[2]
    $'\e[1;33;40m'  # orange  ## col[3]
    $'\e[1;34;40m'  # cyan    ## col[4]
    $'\e[1;35;40m'  # magenta ## col[5]
)


#set wallpaper with feh
set_wallpaper() {
    if command -v feh &> /dev/null ; then
        feh --no-fehbg --bg-scale $(cat $HOME/.cache/wal/wallpaper) &
    else
        1>&2 printf "${col[1]}executable: ${col[3]}feh${col[1]} is not fond in your \$PATH, install it with ${col[3]}your system package manager${col[0]}\n"
    fi
}


# run external script
external_script() {
    if [[ ! -z $_arg_script ]]; then
        if [[ -f $_arg_script ]]; then
            bash $_arg_script &
        else
            1>&2 printf "${col[1]}path: ${col[3]}$_arg_script${col[1]} is not a valid file${col[0]}\n"
            exit
        fi
    elif [[ ! -z $LULE_S ]]; then
        if [[ -f $LULE_S ]]; then
            bash $LULE_S &
        else
            1>&2 printf "${col[1]}path: ${col[3]}$LULE_S${col[1]} is not a valid file${col[0]}\n"
            exit
        fi

    fi
}

# generate ALL ANSI COLORS
rainbow() {
    # If the '-e' flag is passed, cells will be three rows high.
    [[ "$_arg_color_e" == "true" ]] && expanded=true || expanded=false

    # If the option --sixteen is given, only show the first 16 colors
    [[ "$_arg_color_16" == "true" ]] && showall=true sixteen=true expanded=true || sixteen=false

    # Creates a color row -- Arguments: - width (number) - starting color (number) - ending color (number)
    row () {
        # Give the arguments names for scope reasons.
        width=$(($1 - 2))
        start=$2
        end=$3
        # Creates a "slice" (one terminal row) of a row. -- Arguments: - label (boolean)
        slice () {
            for ((i=$start; i<=$end; i++))
            do
                if [ $1 ]; then string=$i; else string=' '; fi
                # Change background to the correct color.
                tput setab $i
                # Print the cell.
                printf "%${width}s " $string
            done
            # Clear the coloring to avoid nasty wrapping colors.
            tput sgr0
            echo
        }
        if [ $expanded == true ]; then
            slice; slice true; slice
        else
            slice true
        fi
    }

    # 0-15.
    echo
    row $(($(tput cols)/8)) 0 7
    row $(($(tput cols)/8)) 8 15
    echo
    [[ $sixteen == true ]] && exit

    # 16-231.
    for ((a=0; a<=17; a++)) do
        row $(($(tput cols)/12)) $((16 + (12 * a))) $((27 + (12 * a)))
    done
    echo

    # 232-255.
    row $(($(tput cols)/12)) 232 243
    tput setaf 0
    row $(($(tput cols)/12)) 244 255

    # Clear before exiting.
    tput sgr0
    echo
}


# generate colors from wallaper with different tools
_optional_paletes=(pigmnts schemer2 convert imgscheme)
_optional_paletes_sources=(
    "https://github.com/blenderskool/pigmnts" 
    "https://github.com/thefryscorer/schemer2"
    "https://github.com/ImageMagick/ImageMagick" 
    "https://github.com/wwalexander/imgscheme"
)
_arg_palette=${_optional_paletes[0]}
palette() {
    if ! command -v "$_arg_palette" &> /dev/null ; then
        1>&2 printf "${col[1]}executable: ${col[3]}$_arg_palette${col[1]} is not fond in your \$PATH, please install it or check:${col[3]} lule palette -s${col[0]}\n" && exit
    fi

    local wallpaper=$(cat $HOME/.cache/wal/wallpaper)
    if [[ $_arg_palette == "${_optional_paletes[0]}" ]]; then
        pigmnts -c 16 $wallpaper -q
    elif [[ $_arg_palette == "${_optional_paletes[1]}" ]]; then
        schemer2 -format img::colors -in $wallpaper
    elif [[ $_arg_palette == "${_optional_paletes[2]}" ]]; then
        convert $wallpaper +dither -colors 16 -unique-colors txt: | tail -n +2 | cut -d" " -f4 | tac
    elif [[ $_arg_palette == "${_optional_paletes[3]}" ]]; then
        imgscheme $wallpaper
    fi
}


all_paletes(){
    for index in ${!_optional_paletes[*]}; do 
        if [[ "$_arg_paletter_s" == "true" ]]; then
            printf " - ${col[3]}${_optional_paletes[$index]}\'s${col[0]} source code is in:\n\t${col[3]}${_optional_paletes_sources[$index]}${col[0]}\n\n"
        elif [[ "$_arg_paletter_c" == "true" ]]; then
            if command -v ${_optional_paletes[$index]} &> /dev/null ; then
                printf " - ${_optional_paletes[$index]} executable ${col[3]}exists${col[0]} in: $(command -v ${_optional_paletes[$index]})\n"
            else
                printf " - ${_optional_paletes[$index]} executable ${col[1]}does not exists${col[0]} in your path, run${col[3]} lule palette -s ${col[0]} to see source link\n"
            fi
        else
            _arg_palette=${_optional_paletes[$index]}
            printf "\nColors generated from palete: ${_optional_paletes[$index]}\n"
            palette | pastel -f saturate 0.1 | pastel sort-by -r chroma | head -n 10 | pastel format hex
        fi
    done
}

#get_new image as wallpaper (not set, just get it)
new_wallpaper() {
    #if --image and --wallpath are mising and $LULE_W as system variable is not set then throw error
    if [[ -z $_arg_image ]] && [[ -z $LULE_W ]]; then
            1>&2 printf "${col[1]}image not selected with ${col[3]}lule -i <path>${col[1]} or wallpaper directory variable ${col[3]}\$WALLS${col[1]} is not set\nplease set it first and then run:${col[0]}\n"
            usage && exit
    fi
    #if --image is set use as wallpaper
    if [[ ! -z $_arg_image ]]; then
        if file "$_arg_image" | grep -qE 'image|bitmap'; then
            echo "$_arg_image"
        else
            1>&2 printf "${col[1]}path: ${col[3]}$1${col[1]} is not an image${col[0]}\n"
            exit
        fi
    #othervise use --wallpath or $LULE_W (presedence is on --image)
    elif [[ ! -z $LULE_W ]]; then
        #(TODO: check if you can do recursion here)
        if [[ -d $LULE_W ]]; then
            image_to_set=$(find $LULE_W -maxdepth 1 | shuf -n 1)
            if file "$image_to_set" | grep -qE 'image|bitmap'; then
                echo "$image_to_set"
            else
                1>&2 printf "${col[1]}path: ${col[3]}$image_to_set${col[1]} is not an image${col[0]}\n"
                exit
            fi
        else
            1>&2 printf "${col[1]}path: ${col[3]}$LULE_W${col[1]} is not a valid directory${col[0]}\n"
            exit
        fi
    fi
}


check_colorz() {
    if [ ! -f /tmp/colorz ]; then
        # new_wallpaper
        1>&2 printf "${col[1]}please set a colorscheme first with ${col[3]}lule new${col[1]} and run again or use different command:${col[0]}\n"
        usage && exit
    fi
}


### adjust accent color based on dark/light theme
adjust_primary(){
    if [ $(cat $HOME/.cache/wal/theme) == "light" ] ; then
        ac=$(cat /tmp/rainbow | head -n 1 | pastel set hsl-lightness 0.3 | pastel format hex)
        echo light > $HOME/.cache/wal/theme
    else
        ac=$(cat /tmp/rainbow | head -n 1 | pastel set hsl-lightness 0.7 | pastel format hex)
        echo dark > $HOME/.cache/wal/theme
    fi
}


generate_colors(){
    adjust_primary
    ### === COLOR-GENERATION ===
    col0=$(pastel -f mix $ac -f 0.08 "#000000" | pastel format hex)
    col1=$(echo $ac | pastel -f saturate 0.1 | pastel format hex)
    col7=$(pastel -f mix $ac -f 0.2 "#aaaaaa" | pastel format hex)
    col8=$(pastel -f mix $ac -f 0.2 "#666666" | pastel format hex)
    col15=$(pastel -f mix $ac -f 0.12 "#ffffff" | pastel format hex)
    # additional color generation (mix between accent and primary colors)
    redish=$(pastel -f mix $ac -f 0.5 "#ff0000" | pastel -f saturate 0.2)
    blueish=$(pastel -f mix $ac -f 0.5 "#0000ff" | pastel -f saturate 0.2)
    greenish=$(pastel -f mix $ac -f 0.5 "#00ff00"| pastel -f saturate 0.2)

    ### invert black/white theme based on theme selected
    if [ $(cat $HOME/.cache/wal/theme) == "light" ] ; then
        white="#000000"
        black="#ffffff"
        back=$col15 
        fore=$col0
    else
        black="#000000"
        white="#ffffff"
        back=$col0
        fore=$col15
    fi

    ### === COLOR-CONCATINATION ===
    #concatinating main colors (colors 0-15)
    echo $back > $HOME/.cache/wal/colors
    echo $col1 >> $HOME/.cache/wal/colors
    cat /tmp/rainbow | tail -n 5 | pastel -f mix -f 0.2 $fore | pastel format hex >> $HOME/.cache/wal/colors
    echo $col7 >> $HOME/.cache/wal/colors
    echo $col8 >> $HOME/.cache/wal/colors
    cat /tmp/rainbow | pastel -f mix -f 0.2 $back | pastel format hex >> $HOME/.cache/wal/colors
    echo $fore >> $HOME/.cache/wal/colors
    #generating shades of each additional color (colors 16-51)
    pastel -f gradient $back $redish $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    pastel -f gradient $back $greenish $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    pastel -f gradient $back $blueish $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    #generating shades of each additional color (colors 52-135)
    pastel -f gradient $back '#ff0000' $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    pastel -f gradient $back '#00ff00' $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    pastel -f gradient $back '#0000ff' $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    pastel -f gradient $back '#ff00ff' $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    pastel -f gradient $back '#ffff00' $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    pastel -f gradient $back '#00ffff' $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    pastel -f gradient $back '#888888' $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    #generating shades of each additional color (colors 136-196)
    pastel -f gradient $back $(pastel -f random -n 1) $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    pastel -f gradient $back $(pastel -f random -n 1) $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    pastel -f gradient $back $(pastel -f random -n 1) $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    pastel -f gradient $back $(pastel -f random -n 1) $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    pastel -f gradient $back $(pastel -f random -n 1) $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    pastel -f gradient $back $(pastel -f random -n 1) $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    pastel -f gradient $back $(pastel -f random -n 1) $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    pastel -f gradient $back $(pastel -f random -n 1) $fore -n 14 | xargs -0 | head -n -2 | tail -n +2 | pastel format hex >> $HOME/.cache/wal/colors
    #generating gradients (colors 232-255)
    pastel -f gradient $black $back -n 3 | xargs -0 | head -n -1 | pastel format hex >> $HOME/.cache/wal/colors 
    pastel -f gradient $back $col1 $fore -n 18 | xargs -0 | head -n -1 | pastel format hex >> $HOME/.cache/wal/colors 
    pastel -f gradient $fore $white -n 3 | xargs -0 | head -n -1 | pastel format hex >> $HOME/.cache/wal/colors 
}



create_files(){
    ### === PRINTING THINGS TO FILES === ###
    wallpaper=$(cat $HOME/.cache/wal/wallpaper)
    theme=$(cat $HOME/.cache/wal/theme)
    # COLORS.SH (used by shells - bash,zsh,fish...)
    printf "foreground=\"$fore\"\nbackground=\"$back\"\ncursor=\"$col1\"\n" > $HOME/.cache/wal/colors.sh
    awk '{print "color" NR-1 "=\"" $0 "\""}' $HOME/.cache/wal/colors >> $HOME/.cache/wal/colors.sh

    # COLORS.YAML (used by ALACRITY)
    printf "special:\n\tbackground: \"$back\"\n\tforeground: \"$fore\"\n\tcursor: \"$col1\"\n\ncolors:\n" > $HOME/.cache/wal/colors.yml
    awk '{print "\tcolor" NR-1 ": \"" $0 "\""}' $HOME/.cache/wal/colors >> $HOME/.cache/wal/colors.yml

    # COLORS.JSON (used by FREFOX)
    printf "{\n\t\"wallpaper\": \"$wallpaper\",\n\t\"theme\": \"$theme\",\n" > $HOME/.cache/wal/colors.json
    printf "\t\"special\": {\n\t\t\"background\": \"$back\",\n\t\t\"foreground\": \"$fore\",\n\t\t\"cursor\": \"$col1\"\n\t},\n\t\"colors\": {\n" >> $HOME/.cache/wal/colors.json
    awk '{print "\t\t\"color" NR-1 "\": \"" $0 "\","}' $HOME/.cache/wal/colors >> $HOME/.cache/wal/colors.json
    truncate -s-2 $HOME/.cache/wal/colors.json; printf "\n\t}\n}" >> $HOME/.cache/wal/colors.json

    # COLORS.INI (used by POLYBAR)
    printf "[colors]\n\tforeground=$fore\n\tbackground=$back\n\tcursor=$col1\n" > $HOME/.cache/wal/colors.ini
    awk '{print "\tcolor" NR-1 "=" $0 }' $HOME/.cache/wal/colors >> $HOME/.cache/wal/colors.ini

    # COLORS.CONF (used by KITTY)
    printf "foreground\t$fore\nbackground\t$back\ncursor\t$col1\n\n" > $HOME/.cache/wal/colors.conf
    awk '{print "color" NR-1 "\t " $0}' $HOME/.cache/wal/colors >> $HOME/.cache/wal/colors.conf

    # SEQUENCES (escape codes sent to all '/dev/pts/*')
    printf "]10;$fore\\]11;$back\\]12;$col1\\]13;$back\\]17;$col1\\]19;$back\\" > $HOME/.cache/wal/sequences
    awk '{print "]4;" NR-1 ";" $0"\\"}' ORS='' $HOME/.cache/wal/colors >> $HOME/.cache/wal/sequences
}

### MAIN COMMANDS
_nocommnd=true
_positional_commands=(set pick regen theme)
choose_command(){
    if [[ $_command == "${_positional_commands[0]}" ]]; then
        new_wallpaper > $HOME/.cache/wal/wallpaper
        palette > /tmp/colorz
        cat /tmp/colorz | pastel -f saturate 0.1 | pastel sort-by -r chroma | head -n 6 | pastel format hex > /tmp/rainbow

    elif [[ $_command == "${_positional_commands[1]}" ]]; then
        check_colorz
        picked=$(pastel -f pick | pastel format hex)
        [[ -z $picked ]] && exit || echo $picked > /tmp/rainbow
        cat /tmp/colorz | pastel -f saturate 0.1 | pastel sort-by -r chroma | head -n 6 | tail -n 5 | pastel format hex >> /tmp/rainbow

    elif [[ $_command == "${_positional_commands[2]}" ]]; then
        check_colorz
        palette > /tmp/colorz
        cat /tmp/colorz | pastel -f saturate 0.1 | pastel sort-by -r chroma | head -n 6 | pastel format hex > /tmp/rainbow

    elif [[ $_command == "${_positional_commands[3]}" ]]; then
        check_colorz
        [[ $(cat $HOME/.cache/wal/theme) == "dark" ]] && echo light > $HOME/.cache/wal/theme || echo dark > $HOME/.cache/wal/theme
        cat /tmp/colorz | pastel -f saturate 0.1 | pastel sort-by -r chroma | head -n 6 | pastel format hex > /tmp/rainbow
    fi
}


### SPECIAL COMMANDS
_nospecial=true
_positional_specals=(colors palette configs)
choose_special() {
    if [[ $_special == "${_positional_specals[0]}" ]]; then
        rainbow
        exit
    fi
    if [[ $_special == "${_positional_specals[1]}" ]]; then
        all_paletes
        exit
    fi
    if [[ $_special == "${_positional_specals[2]}" ]]; then
        logo
        exit
    fi
}


logo(){
    declare -ra rain=(
        $(tput sgr0)
        $(tput setaf $(( 69 + 1 )) )
        $(tput setaf $(( 81 + 1 )) )
        $(tput setaf $(( 105 + 1 )) )
        $(tput setaf $(( 117 + 1 )) )
        $(tput setaf $(( 93 + 1 )) )
        $(tput setaf $(( 57 + 1 )) )
    )

    printf "                       ${rain[6]}▐▓                                                       ${rain[0]}\n"
    printf "                       ${rain[6]}▐▓▓▓▄                                                    ${rain[0]}\n"
    printf "                       ${rain[6]}▓▓▓▓▓▓▓▓▄▄▄▄                      ${rain[1]}▄▄▓▓▓                 ${rain[0]}\n"
    printf "                       ${rain[6]}▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄▄               ${rain[1]}▄▓▓▓▓▓▓▌                 ${rain[0]}\n"
    printf "                       ${rain[6]}▓▓▓▓▓▓▓▀ ▓▓▓▓▓▓▓▓          ${rain[1]}▄▓▓▓▓▓▓▓▓▓▓                  ${rain[0]}\n"
    printf "                       ${rain[6]}▓▓▓▓▓▓▓▓▄▄ ▀▓▓▓▓▓▓       ${rain[1]}▄▓▓▓▓▓▓▓▓▓▓▓▓▓                  ${rain[0]}\n"
    printf "                       ${rain[6]}▐▓▓▓▓▓▓▓▓▓▓  ▀▓▓▓▓▓    ${rain[1]}▓▓▓▓▓▓▓▓▓▓▀▀▓▓▓▓                  ${rain[0]}\n"
    printf "                        ${rain[6]}▓▓▓▓▓▓▓▓▓▓▓▄  ▓▓▓▓   ${rain[1]}▓▓▓▓▓▓▓▓▓▓▓ ▄▓▓▓▓▓                 ${rain[0]}\n"
    printf "                         ${rain[6]}▀▓▓▓▓▓▓▓▓▓▓▓  ▐▓▌ ${rain[1]}▐▓▓▓▓▓▓▓▓▓▓▀ ▐▓▓▓▓▓▓                 ${rain[0]}\n"
    printf "               ${rain[5]}▄▓▓▓▓▓▄▄    ${rain[6]}▀▓▓▓▓▓▓▓▓▓▌  ▓   ${rain[1]}▓▓▓▓▓▓▓▓▓   ▓▓▓▓▓▓                  ${rain[0]}\n"
    printf "           ${rain[5]}▄▓▒▒▒▒▒▒▒▒▒▒▒▒▓▄   ${rain[6]}▀▓▓▓▓▓▓▓  ▓  ${rain[1]}▐▓▓▓▓▓▓▓   ▄▓▓▓▓▓                    ${rain[0]}\n"
    printf "         ${rain[5]}▄▓▒▒▒▒▒▒▒▓▓▀▀▀▀▀▓▓▓▓▄   ${rain[6]}▀▓▓▓▓     ${rain[1]}▓▓▓▓▓▀   ▄▓▓▓▓▀                      ${rain[0]}\n"
    printf "      ${rain[5]}▄▓▒▒▒▒▒  ▓ ▄▄▄▄▄▄       ▀    ${rain[6]}▀▓▓    ${rain[1]}▓▓▓▀   ▄▓▓▀                           ${rain[0]}\n"
    printf "  ${rain[5]}▓▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▒▒▒▓▓▄       ${rain[6]}▌               ${rain[2]}▄▓▒▒▒▒▒▒▒▒▒▓▓▄             ${rain[0]}\n"
    printf "     ${rain[5]}▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▄          ${rain[2]}▄▄▄▄▄▄▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▄         ${rain[0]}\n"
    printf "        ${rain[5]}▀▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▀▀▀▀           ${rain[2]}▀▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▄     ${rain[0]}\n"
    printf "            ${rain[5]}▀▓▓▒▒▒▒▒▒▒▒▒▒▓▀               ${rain[3]}▒       ${rain[2]}▀▓▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▓▓   ${rain[0]}\n"
    printf "                           ${rain[4]}▄▄░    ▄▓▓▓    ${rain[3]}▒▓     ${rain[2]}▄       ▀▀▀▀▀▀▀ ▄▒▒▒▒▒▓▀       ${rain[0]}\n"
    printf "                      ${rain[4]}▄▓▒▒▓    ▄▓▒▒▒▓     ${rain[3]}▒▒▒▓    ${rain[2]}▀▓▓▓▄▄▄▄▄▓▓▓▒▒▒▒▒▒▓▀          ${rain[0]}\n"
    printf "                    ${rain[4]}▓▒▒▒▒    ▓▒▒▒▒▒▒   ${rain[3]}▒  ▒▒▒▒▒▓▓▄   ${rain[2]}▀▓▒▒▒▒▒▒▒▒▒▒▒▓▀            ${rain[0]}\n"
    printf "                  ${rain[4]}▓▒▒▒▒▓   ▓▒▒▒▒▒▒▒▒   ${rain[3]}▒  ▓▒▒▒▒▒▒▒▒▓▄    ${rain[2]}▀▀▀▀▀▀▀                ${rain[0]}\n"
    printf "                 ${rain[4]}▓▒▒▒▒▒  ▓▒▒▒▒▒▒▒▒▒▒  ${rain[3]}▓▒   ▒▒▒▒▒▒▒▒▒▒▓                          ${rain[0]}\n"
    printf "                 ${rain[4]}▒▒▒▒▒▓ ▓▒▒▒▒▒▒▒▒▒▒▓  ${rain[3]}▒▒▓  ▓▒▒▒▒▒▒▒▒▒▒▒                         ${rain[0]}\n"
    printf "                 ${rain[4]}▓▒▒▒▓ ▄▒▒▒▒▒▒▒▒▒▓    ${rain[3]}▒▒▒▒▓  ▀▒▒▒▒▒▒▒▒▒▒                        ${rain[0]}\n"
    printf "                  ${rain[4]}▒▒▒▒▒▒▒▒▒▒▒▒▒▀      ${rain[3]}▓▒▒▒▒▒▓▄ ▓▓▒▒▒▒▒▒▒                        ${rain[0]}\n"
    printf "                  ${rain[4]}▓▒▒▒▒▒▒▒▒▒▓          ${rain[3]}▀▒▒▒▒▒▒▒▓  ▒▒▒▒▒▒▌                       ${rain[0]}\n"
    printf "                  ${rain[4]}▓▒▒▒▒▒▓▀               ${rain[3]}▀▓▒▒▒▒▒▒▒▒▒▒▒▒▒▌                       ${rain[0]}\n"
    printf "                  ${rain[4]}▒▒▓▀                       ${rain[3]}▀▀▓▓▒▒▒▒▒▒▒                        ${rain[0]}\n"
    printf "                                                    ${rain[3]}▓▒▒▒                        ${rain[0]}\n"
    printf "                                                      ${rain[3]}▀▒                        ${rain[0]}\n"
}


#print main usage
USE="true"
usage() {
    if [[ $ALL == "true" ]] ; then
        printf "${col[2]}lule v.$VERSION${col[0]}\na command line to set 255 colors on tty's and other places that use ANSI colors\n"
    fi
    if [[ $USE == "true" ]] ; then
    printf "\n${col[2]}USAGE:${col[0]}\n\
    lule [options][flags] <command>\n\
    lule <special> [flags]\n"

    printf "\n${col[2]}OPTIONS:${col[0]}\n\
    ${col[2]}--palette[=]<name>${col[0]} -> "; for index in ${!_optional_paletes[*]}; do printf "${col[3]}${_optional_paletes[$index]}, ${col[0]}"; done
    printf "\n\tspecify the palete binary to use\n\
    ${col[2]}--configs[=]<filepath>${col[0]} :: or specify ${col[3]}\$LULE_C${col[0]} as environment variable
    \tspecify a config file where to load color preferences${col[1]} - WIP${col[0]}\n\
    ${col[2]}--image[=]<filepath>${col[0]}
    \tspecify the image to extract colors from\n\
    ${col[2]}--script[=]<filepath>${col[0]} :: or specify ${col[3]}\$LULE_S${col[0]} as environment variable
    \tspecify an external script to run after colors are genrated\n\
    ${col[2]}--wallpath[=]<dirpath>${col[0]} :: or specify ${col[3]}\$LULE_W${col[0]} as environment variable
    \tspecify a folder to pick an image randomly\n\
    ${col[2]}--loop[=]<seconds>${col[0]} -> only ${col[3]}numbers${col[0]} are valid
    \tloop thrugh direcory (needs ${col[3]}\$LULE_W${col[0]} or ${col[3]}\$--wallpath${col[0]})\n"

    printf "\n${col[2]}FLAGS:${col[0]}\n\
    ${col[2]}-n ${col[0]}\tdont set wallpaper\n\
    ${col[2]}-d ${col[0]}\tdont set colors\n\
    ${col[2]}-r ${col[0]}\trefresh the colors ${col[2]} - alone${col[0]}\n"

    printf "\n${col[2]}COMMANDS:${col[0]}\n\
    ${col[2]}${_positional_commands[0]}${col[0]} \t generate new colors from new image\n\
    ${col[2]}${_positional_commands[1]}${col[0]} \t pick a color as accent color\n\
    ${col[2]}${_positional_commands[2]}${col[0]} \t generate new colors from same image\n\
    ${col[2]}${_positional_commands[3]}${col[0]} \t invert dark and light theme\n"

    printf "\n${col[2]}SPECIAL:${col[0]}\n\
    ${col[2]}${_positional_specals[0]} [flags]${col[0]} \t print all 255 colors in terminal\n\
    ${col[2]}${_positional_specals[1]} [flags]${col[0]} \t more info about diffenert palette generators\n\
    ${col[2]}${_positional_specals[2]} [flags]${col[0]} \t set and save color configure options${col[1]} - WIP${col[0]}\n\
    info for flags of each special command with: ${col[3]}lule <special> -h ${col[0]}\n"
    fi
}


#print special command "colors" usage
usage_colors() {
    printf "${col[2]}lule ${_positional_specals[0]}${col[0]}\nprint ANSI colors in terminal\n"

    printf "\n${col[2]}USAGE:${col[0]}\n\
    lule ${_positional_specals[0]} [flag]\n"

    printf "\n${col[2]}FLAGS:${col[0]}\n\
    ${col[2]}-e  ${col[0]}\tshow thicker/bigger colors\n\
    ${col[2]}-16 ${col[0]}\tshow only 16 primary colors\n"
}


#print special command "palette" usage
usage_palette() {
    printf "${col[2]}lule ${_positional_specals[1]}${col[0]}\ninfo about diffenert palette generators\n"

    printf "\n${col[2]}USAGE:${col[0]}\n\
    lule ${_positional_specals[1]} [flag]\n"

    printf "\n${col[2]}FLAGS:${col[0]}\n\
    ${col[2]}-s ${col[0]}\tprint sources of different tools\n\
    ${col[2]}-c ${col[0]}\tcheck which palete binaries are installed\n"
}

parse_command_options() {
    _positionals_count=0
    _optionals_count=0
    while test $# -gt 0
    do
        _key="$1"
        case "$_key" in
            --loop)
                if [[ $# -lt 2 ]]; then 1>&2 printf "${col[1]}Missing value for the argument: ${col[3]}'$_key'.\n${col[0]}" && usage && exit; fi
                _arg_loop="$2"
                shift
                ;;
            --loop=*)
                _arg_loop="${_key##--palette=}"
                ;;
            --script)
                if [[ $# -lt 2 ]]; then 1>&2 printf "${col[1]}Missing value for the argument: ${col[3]}'$_key'.\n${col[0]}" && usage && exit; fi
                _arg_script="$2"
                shift
                ;;
            --script=*)
                _arg_script="${_key##--palette=}"
                ;;
            --palette)
                if [[ $# -lt 2 ]]; then 1>&2 printf "${col[1]}Missing value for the argument: ${col[3]}'$_key'.\n${col[0]}" && usage && exit; fi
                _arg_palette="$2"
                shift
                ;;
            --palette=*)
                _arg_palette="${_key##--palette=}"
                ;;
            --image)
                if [[ $# -lt 2 ]]; then 1>&2 printf "${col[1]}Missing value for the argument: ${col[3]}'$_key'.\n${col[0]}" && usage && exit; fi
                _arg_image="$2"
                shift
                ;;
            --image=*)
                _arg_image="${_key##--image=}"
                ;;
            --wallpath)
                if [[ $# -lt 2 ]]; then 1>&2 printf "${col[1]}Missing value for the argument: ${col[3]}'$_key'.\n${col[0]}" && usage && exit; fi
                _arg_wallpath="$2"
                LULE_W=$_arg_wallpath
                shift
                ;;
            --wallpath=*)
                _arg_wallpath="${_key##--wallpath=}"
                LULE_W=$_arg_wallpath
                ;;
            -n)
                _arg_n="true"
                ;;
            -d)
                _arg_d="true"
                ;;
            -r)
                _arg_r="true"
                ;;
            -h|--help)
                ALL=true
                usage
                exit
                ;;
            -v|--version)
                echo $VERSION
                exit
                ;;
            *)
                _last_positional="$1"
                _positionals+=("$_last_positional")
                _positionals_count=$((_positionals_count + 1))
                ;;
        esac
        shift
    done
}


assign_positional_args() {
    #if lule -r is used, make an exception, allow it without positionals
    if [[ "$_arg_r" == "true" ]]; then
        return
    elif [[ "${_positionals_count}" -gt 1 ]] ; then
        1>&2 printf "${col[1]}There were spurious positional arguments --- we expect exactly 1 but got ${col[3]}${_positionals_count}${col[0]}\n"
        usage
        exit
    fi

    local _positional_name 
    shift "$1"
    for _positional_name in ${_positional_commands[@]}
    do
        if [ "${1}" == "$_positional_name" ] ; then
            _nocommnd=false
            _command="${1}"
        fi
    done

    if [[ "$_nocommnd" == "true" ]] ; then
        1>&2 printf "${col[1]}Incorret useage of arguments --- we expect exact one of those commands:${col[0]}\n"
        usage
        exit
    fi
}


parse_special_options_colors() {
    _positionals_count=0
    _optionals_count=0
    while test $# -gt 0
    do
        _key="$1"
        case "$_key" in
            -e)
                _arg_color_e="true"
                ;;
            -16)
                _arg_color_16="true"
                ;;
            -h|--help)
                usage_colors
                exit
                ;;
            *)
                1>&2 printf "${col[1]}Incorret useage ot arguments --- we expect exact one of those commands:${col[0]}\n"
                usage_colors
                exit
                ;;
        esac
        shift
    done
}

parse_special_options_palette() {
    _positionals_count=0
    _optionals_count=0
    while test $# -gt 0
    do
        _key="$1"
        case "$_key" in
            -c)
                _arg_paletter_c="true"
                ;;
            -s)
                _arg_paletter_s="true"
                ;;
            -h|--help)
                usage_palette
                exit
                ;;
            *)
                1>&2 printf "${col[1]}Incorret useage ot arguments --- we expect exact one of those commands:${col[0]}\n"
                usage_palette
                exit
                ;;
        esac
        shift
    done
}


#sent color sequences to all ppts (most important piece of this script)
colors_to_tty(){
    for tt in /dev/pts/*; do 
        re='^[0-9]+$'; [[ $(basename $tt) =~ $re ]] && /usr/bin/cat $HOME/.cache/wal/sequences > $tt; 
    done
}

#apply all colors (or specific command) to nvim needs 'pip install neovim-remote' and 'lsof'
colors_to_nvim(){
    if command -v nvr &> /dev/null ; then
        for i in `pidof nvim`; do 
            for e in `lsof -p "$i" | grep LISTEN | awk -v N=$9 '{print $9}'`; do
                nvr --nostart --servername $e -c ":lua mycolors(\"$(cat $HOME/.cache/wal/theme)\")" &
            done
        done
    else
        1>&2 printf "${col[1]}executable: ${col[3]}nvr${col[1]} is not fond in your \$PATH, install it with ${col[3]}'pip install neovim-remote'${col[0]}\n"
    fi
}


run_special() {
    choose_special
}

run_command_generate_colors(){
    choose_command
    generate_colors
    create_files
}

run_command_update_colors(){
    if [[ ! "$_arg_n" == "true" ]]; then
        set_wallpaper
    fi
    if [[ ! "$_arg_d" == "true" ]]; then
        colors_to_tty &
        colors_to_nvim &
    fi
    external_script
}

# run commands in loop if specified
run_command_in_loop(){
    re='^[0-9]+$'; 
    if [[ $_arg_loop =~ $re ]]; then
        while true; do
            run_command_generate_colors
            run_command_update_colors
            sleep $_arg_loop
        done
    else
        1>&2 printf "${col[3]}--loop${col[1]} argument is not a ${col[3]}number${col[0]}\n"
        exit
    fi
}


# if no arguments print help
if [[ -z $@ ]] ; then
    if ! command -v pastel &> /dev/null ; then
        1>&2 printf "please install ${col[3]}pastel${col[0]} before using ${col[3]}lule${col[0]}, because it's the heart of this tool\n"
        1>&2 printf "for more info on how to install it, please check: ${col[3]}https://github.com/sharkdp/pastel${col[0]}\n"
        exit
    fi
    logo
    ALL=true
    usage
    exit
fi


# check if first argument is special
for _positional_name in ${_positional_specals[@]}; do
    if [ "${1}" == "$_positional_name" ] ; then
        _nospecial=false
        _special="${1}"
        shift
    fi
done


# parse commands or specials
if [[ "$_nospecial" == "true" ]] ; then
    if ! command -v pastel &> /dev/null ; then
        1>&2 printf "please install ${col[3]}pastel${col[0]} before using ${col[3]}lule${col[0]}, because it's the heart of this tool\n"
        1>&2 printf "for more info on how to install it, please check: ${col[3]}https://github.com/sharkdp/pastel${col[0]}\n"
        exit
    fi
    parse_command_options "$@"
    assign_positional_args 1 "${_positionals[@]}"
    if [[ ! -z $_arg_loop ]]; then
        run_command_in_loop
    else
        if [[ ! "$_arg_r" == "true" ]]; then
            run_command_generate_colors
        fi
        run_command_update_colors
    fi
else
    if [[ "$_special" == ${_positional_specals[0]} ]] ; then
        parse_special_options_colors "$@"
    fi
    if [[ "$_special" == ${_positional_specals[1]} ]] ; then
        parse_special_options_palette "$@"
    fi
    run_special
fi
